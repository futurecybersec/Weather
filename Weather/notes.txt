The documentation states "The Open-Meteo Swift SDK is your go-to tool for seamlessly integrating weather data into your Swift applications. It leverages the power of binary encoded FlatBuffer messages to swiftly transmit data from the Open-Meteo API to your client. This innovative approach eliminates the need for resource-intensive parsing, delivering a substantial speed boost to any app that relies on weather data." What are binary encoded FlatBuffer messages?

ChatGPT:

Alright — let’s unpack that into something less “press-release” and more “developer-brain-friendly.”

⸻

What FlatBuffers are

FlatBuffers is a binary serialization format created by Google.
	•	Serialization → turning data (like Swift structs) into a format that can be sent over a network or saved to disk.
	•	Binary → stored as raw bytes, not text like JSON or XML.
	•	Flat → data is stored in a single contiguous block of memory, so it can be read directly without unpacking/re-parsing into another structure.

⸻

Why it matters

Normally, with JSON:
	1.	The API sends text like "temperature": 23.4.
	2.	Your app parses that text into memory, converting strings to numbers.
	3.	This parsing step can be CPU-heavy for large datasets (especially hourly weather for days/weeks).

With FlatBuffers:
	1.	The API sends binary data — numbers are already in numeric form, strings are already offset in memory.
	2.	Your app can read the values directly from the buffer, without parsing or allocating new objects.

That means:
	•	Faster (no expensive parsing)
	•	Lower memory use (no intermediate copies)
	•	Predictable performance (good for large or real-time datasets)

⸻

How it looks conceptually

If JSON is like:

{
  "temperature": 23.4,
  "time": "2025-08-13T12:00Z"
}

then a FlatBuffer message might be like:

[Binary data here: 42 bytes of raw numbers and offsets]

And instead of calling JSONDecoder, you call something like:

let temp = hourly.variables(at: 0)?.values[0]

and that number is read directly from the buffer — no parsing needed.

⸻

Why Open-Meteo uses it

Weather data often means big arrays:
	•	Hourly temperatures
	•	Hourly precipitation
	•	Daily highs/lows
Sending that as JSON would mean thousands of strings and commas, which would:
	•	Be slower to download (larger file)
	•	Be slower to parse (CPU time)
FlatBuffers shrink and speed up the transfer.

⸻

If you want, I can show you a visual comparison of memory and parsing steps between JSON and FlatBuffers so it’s clearer why Open-Meteo calls it a “speed boost.”







I am trying to use a weather api from open-meta.com. The example code on the website does not seem to work properly. I get an error message Cannot convert value of type 'Float32' (aka 'Float') to expected argument type '[Float]'

ChatGPT:

You’re super close! Two issues are causing that error:
    1.    Your model expects an array [Float], but you’re passing a single value.
value returns a single Float, while you need the array of values (values).
    2.    You’re reading from current, but your request only asks for hourly data.
Your URL has hourly=temperature_2m (no current=...), so response.current will be nil. You should pull the series from response.hourly.

Here’s a minimal fix for your getWeather() body:

func getWeather() async throws {
    let endpoint = "https://api.open-meteo.com/v1/forecast?latitude=52.55615&longitude=-1.37098&hourly=temperature_2m&format=flatbuffers"
    guard let url = URL(string: endpoint) else { throw WeatherError.invalidURL }

    let responses = try await WeatherApiResponse.fetch(url: url)
    let response = responses[0]

    let utcOffsetSeconds = response.utcOffsetSeconds
    guard let hourly = response.hourly else { throw WeatherError.invalidResponse }

    // Times for each hourly sample
    let times = hourly.getDateTime(offset: utcOffsetSeconds)

    // "temperature_2m" is the first (and only) hourly variable we requested.
    // Use `values` (plural) to get the whole array, not `value`.
    guard let temps = hourly.variables(at: 0)?.values as? [Float] else {
        throw WeatherError.invalidData
    }

    let data = WeatherData(
        hourly: .init(
            time: times,
            temperature2m: temps
        )
    )

    print("Samples: \(data.hourly.time.count) hours, \(data.hourly.temperature2m.count) temps")
}

If you did want the current temperature instead, change the URL and access current:

// Add current
let endpoint = "https://api.open-meteo.com/v1/forecast?latitude=52.55615&longitude=-1.37098&hourly=temperature_2m&current=temperature_2m&format=flatbuffers"

// Later:
if let current = response.current,
   let tNow = current.variables(at: 0)?.value as? Float {
    print("Current temperature: \(tNow)°C")
}

Why the error happened
    •    WeatherData.Hourly.temperature2m is [Float].
    •    current!.variables(at: 0)!.value is a single Float.
    •    Swift: “Cannot convert value of type ‘Float32’ to expected argument type ‘[Float]’.”

So switch to hourly.variables(at: 0)?.values (plural) and you’re good.




Can you explain the highlighted code?

let data = WeatherData(
    hourly: .init(
        time: times,
        temperature2m: temps
    )
)


ChatGPT:

Yes — that highlighted code is where you’re creating a WeatherData instance from the API’s parsed response.

Here’s what’s happening step-by-step:

⸻

1. WeatherData is your custom model

At the bottom of your file, you’ve defined:

struct WeatherData {
    let hourly: Hourly

    struct Hourly {
        let time: [Date]
        let temperature2m: [Float]
    }
}

That means a WeatherData object stores a group of hourly weather measurements, each with:
    •    time → an array of Date objects for each hourly reading
    •    temperature2m → an array of temperatures (in °C) for those times

⸻

2. Creating an instance

The highlighted code:

let data = WeatherData(
    hourly: .init(
        time: times,
        temperature2m: temps
    )
)

is basically shorthand for:

let hourlyData = WeatherData.Hourly(
    time: times,
    temperature2m: temps
)
let data = WeatherData(hourly: hourlyData)

    •    times → from hourly.getDateTime(offset:), already converted from the API into Date objects
    •    temps → from hourly.variables(at: 0)?.values, which is the temperature data you fetched

The .init(...) syntax is just Swift’s way of saying “call the initializer without explicitly writing the type name,” because the compiler can infer it from context.

⸻

3. Why it’s useful

This step is where you turn raw API data (arrays of dates and floats) into a structured Swift type that’s:
    •    easier to pass around
    •    strongly typed (avoids mismatched data)
    •    ready for SwiftUI or other parts of the app

⸻

If you want, I can also show you how to make this struct Codable so you could decode JSON straight into WeatherData instead of building it manually like this. That would make your code cleaner and less error-prone.


COPY OF CONTENT VIEW BEFORE CHANGING TO JSON FROM FLATBUFFERS

//
//  ContentView.swift
//  Weather
//
//  Created by Mark Darby on 11/08/2025.
//
// Documentation: https://open-meteo.com/
// More info and examples: https://github.com/open-meteo/sdk/tree/main/swift


import OpenMeteoSdk
import SwiftUI

struct ContentView: View {
    @State private var currentTemperature: Float?
    @State private var maxTemp: Float?
    @State private var minTemp: Float?
//    @State private var weatherData: WeatherData?
    
    var formattedTemperature: String {
        currentTemperature?.formatted(.number.rounded(increment: 1.0)) ?? ""
    }
    
    
    
    
    var body: some View {
        VStack {
            CurrentTempView(location: "Hinckley and Bosworth", currentTemperature: formattedTemperature, weatherDescription: "Clear Skies", highTemperature: "28", lowTemperature: "18")
            Spacer()
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(.blue)
        .task {
            do {
                try await getWeather()
            } catch {
                print("Unexpected error")
            }
        }
    }
    func getWeather() async throws {
        // To make it easier this is the API URL from the Chart & URL preview because the code given on the Swift tab is not correct.
        // This gives the actual JSON. Paste into browser to view
        let apiurl = "https://api.open-meteo.com/v1/forecast?latitude=52.5561&longitude=-1.3709&current=temperature_2m&timezone=Europe%2FLondon"
        
        //
        let swifturl =  "\(apiurl)&format=flatbuffers"
        
        // Convert endpoint to URL
        guard let url = URL(string: swifturl) else { throw WeatherError.invalidURL }
        
        
        URLSession.shared.dataTask(with: url) { data, response, error in
                if let error = error {
                    print("Network error: \(error.localizedDescription)")
                    return
                }
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    print("Invalid response")
                    return
                }
                
                guard let data = data else {
                    print("No data received")
                    return
                }
                
                if (200...299).contains(httpResponse.statusCode) {
                    print("Weather data received")
                } else {
                    if let apiError = try? JSONDecoder().decode(WeatherErrorReason.self, from: data) {
                        print("API error: \(apiError.reason)")
                    } else {
                        print("Unknown error, status code: \(httpResponse.statusCode)")
                    }
                }
            }.resume()
        
        
        
        // Get response using API
        let responses = try await WeatherApiResponse.fetch(url: url)
        
        // If single location, the one we want is the first in the array
        let response = responses[0]
        
        // Universal Coordinated Time offset for our location
        let utcOffsetSeconds = response.utcOffsetSeconds
        
        guard let hourly = response.hourly else { throw WeatherError.invalidResponse }

        // Times for each hourly sample
        let times = hourly.getDateTime(offset: utcOffsetSeconds)

        guard let temps = hourly.variables(at: 0)?.values as? [Float] else {
            throw WeatherError.invalidData
        }

        if let current = response.current, let tNow = current.variables(at: 0)?.value as? Float {
            currentTemperature = tNow
        }
        
        let data = WeatherData(
            hourly: .init(
                time: times,
                temperature2m: temps
            )
        )
        
        // Get max temperature
        maxTemp = data.hourly.temperature2m.max()
        
        
        // Timezone '.gmt' is deliberately used.
        // By adding 'utcOffsetSeconds' before, local-time is inferred
//        let dateFormatter = DateFormatter()
//        dateFormatter.timeZone = .gmt
//        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm"
//
//        for (i, date) in data.hourly.time.enumerated() {
//            print(dateFormatter.string(from: date))
//            print(data.hourly.temperature2m[i])
//        }
    }
}

#Preview {
    ContentView()
}

struct WeatherData {
    let hourly: Hourly

    struct Hourly {
        let time: [Date]
        let temperature2m: [Float]
    }
}

struct WeatherErrorReason: Decodable {
    let error: Bool
    let reason: String
}


enum WeatherError: Error {
    case invalidURL
    case invalidResponse
    case invalidData
}
